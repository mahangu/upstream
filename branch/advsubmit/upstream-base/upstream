#!/usr/bin/python
#
# Upstream - log file aggregator and report tool for *nix systems.
# Copyright (C) 2006  Mahangu Weerasinghe (mahangu@gmail.com)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import dialog, sys, time
from getpass import getuser
import  submitmoduleloader, logmoduleloader, uconf, messageframe

import optparse, os, ConfigParser

# Alterations for new backend

# This method takes an exit code from dialog and returns True if success, False if help
# was request, and calls sys.exit if cancel or esc happened

def process_exit_code(code):
	if code == 0:
		return True
	elif code == 2 or code == 1: # ESC/Cancel
		sys.exit(0)
	else:
		return False

def show_welcome(d):
	d.msgbox("This program will assist you in sending troubleshooting data to aid support personnel in diagnosing problems on your system.")
	
def show_submit_choices(d, submit_loader, default):	
	UNSET = -10
	exit_code = UNSET
	exit_info = None
	select_module = None
	submit_loader.join()
	mod_opts_tmp = [[mod.module_name, mod.module_description, 0] for mod in submit_loader]
	for x in mod_opts_tmp:
		if x[0] == default:
			x[2] = 1
	mod_opts = [(x[0], x[1], x[2]) for x in mod_opts_tmp]
	
	# See line 423 in dialog.py for the relevant codes, 5 is DIALOG_HELP, DIALOG_OK == 0
	while exit_code == UNSET or exit_code == 5:
		exit_code, exit_info = d.radiolist(text="Select a submission module", height=15, list_height=7, choices=mod_opts, title="Submit")
		if process_exit_code(exit_code):
			select_module = submit_loader[exit_info]
	return select_module
	
def show_log_choices(d, log_loader):
		
	catchoices = [(cat, "", 0) for cat in log_modules.getCategories()]	
	log_dict = {}
		
	while log_dict == {}:
		(code, categories) = d.checklist(text="Please select categories this problem affects", height=15, width=54, list_height=7, choices=catchoices, title="Problem Description")	
		process_exit_code(code)
		
		for x in categories:
			category = log_modules.getModulesInCategory(x)
			
			for log_module in category:
				module = log_modules[log_module.module_name]
				(name, contents) = module.execute()
				log_dict[name] = contents 
		
		if log_dict == {}:
			d.msgbox("Sorry, but you didn't specify even one category to load logs from. Please try again, or hit CTRL+C to exit this program.")
			
	return log_dict
		
	
def show_password(d, request_tuple):
	pass

def show_username(d):
	nickname = getuser()
	upnickname = ""	
	while upnickname == "":
		code, upnickname = d.inputbox("Please enter your nickname", init="%s"%(nickname))
	process_exit_code(code)
	return upnickname
	
def show_select(d, request_tuple):
	pass

def show_description(d):
	code, result = d.inputbox("Please enter a description of the problem as well", init="")
	process_exit_code(code)
	return result
	
def show_strings(d, request):
	print request
	response =[d.inputbox(r[0], r[1])[1] for r in request[1]]
	return response
	
def show_multistring(d, request):
	pass

def show_info(d, request):
	d.msgbox(request[1])
	
if __name__ == "__main__":
	d = dialog.Dialog(dialog="dialog")
	d.setBackgroundTitle("Upstream Log Transfer System")
	
	config = ConfigParser.ConfigParser()
	config.readfp(open('%s/upstream.conf'%(uconf.base_path_default)))
	submit_module_default = config.get("main", "submit_module_default")
	l_config = uconf.PluginConfigReader(uconf.LOG, "../conf")
	log_modules = logmoduleloader.LogModuleLoader(l_config, True)
	s_config = uconf.PluginConfigReader(uconf.SUBMIT, "../conf")
	submit_modules = submitmoduleloader.SubmitModuleLoader(s_config, True)
	
	show_welcome(d)
	submitter = show_submit_choices(d, submit_modules, submit_module_default)
	if not submitter:
		sys.exit(0)
		print "No module selected"
		
	message_buffer = submitter.getBuffer()
	submitter.execute()
	message = None
	while message != messageframe.DONE and message != messageframe.DONE_ERROR:
		#TODO: Add some kind of nice status message informing the user
		#that we are waiting on signals
		while not message_buffer.frontendMessageWaiting():
			time.sleep(0.1)
		message = message_buffer.frontendReceiveMessage()
		if message[0] == messageframe.INFORMATION:
			show_info(d, message)
		elif message[0] == messageframe.REQUEST_UID:
			message_buffer.frontendSendMessage(show_username(d))
		elif message[0] == messageframe.REQUEST_LOGS:
			message_buffer.frontendSendMessage(show_log_choices(d, log_modules))
		elif message[0] == messageframe.REQUEST_DESCR:
			message_buffer.frontendSendMessage(show_description(d))
		elif message[0] == messageframe.REQUEST_STRINGS:
			message_buffer.frontendSendMessage(show_strings(d, message))
		elif message[0] == messageframe.DONE or message[0] == messageframe.DONE_ERROR:
			show_info(d, message)
			break
		
# End alterations for new backend

"""

Preserve the old thing with a large comment

def main():
	d = dialog.Dialog(dialog="dialog")
	d.add_persistent_args(["--backtitle", "Upstream Log Transfer System"])
	
	#Step 1
	d.msgbox("This program will assist you in sending troubleshooting data to aid support personnel in diagnosing problems on your system.")
	
	#Step 2
	nickname = getuser()
	upnickname = ""
	
	while upnickname == "":
		(code, upnickname) = d.inputbox("Please enter your nickname", init="%s"%(nickname))
		
		if upnickname == "":
			d.msgbox("Sorry, but you didn't specify a name to use. Please try again, or hit CTRL+C to exit this program.")
			
	nickname = upnickname

	
	#Step 3
	log_modules.join()
	catchoices = []
	
	for cat in log_modules.getCategories():	
		catentry = (cat, "", 0)
		catchoices.append(catentry)
	
	
	log_dict = {}
		
	while log_dict == {}:
		(code, categories) = d.checklist(text="Please select categories this problem affects",
					height=15, width=54, list_height=7, 
					choices=catchoices,
					title="Problem Description")
		
		
		
		
		for x in categories:
			category = log_modules.getModulesInCategory(x)
			
			for log_module in category:
				module = log_modules[log_module.module_name]
				(name, contents) = module.execute()
				log_dict[name] = contents 
		
		if log_dict == {}:
			d.msgbox("Sorry, but you didn't specify even one category to load logs from. Please try again, or hit CTRL+C to exit this program.")
		
	
	(code, description) = d.inputbox("Please enter a description of the problem as well", init="")
	

	#Step 4
	submit_modules.join()
	modchoices = []
	
	for mod in submit_modules:
		if mod.module_name == submit_module_default:
			modbool = 1
		else:
			modbool = 0
		
		modentry = (mod.module_name, "", modbool)
		modchoices.append(modentry)
		print modentry
	
	pastebin = ""
	
	while pastebin == "":
		(code, pastebin) = d.radiolist(text="Please select the server to submit troubleshooting data to.",
                	                  height=15, width=54, list_height=7, 
                        	          choices=modchoices,
                                	  title="Submit")
		if pastebin == "":
			d.msgbox("Sorry, but you didn't specify a server to submit to. Please try again, or hit CTRL+C to exit this program.")
				  
	
	print pastebin
	
	submit_module = submit_modules[pastebin]
	
	print submit_module
	
	submit_module.execute(nickname, description, log_dict)
	
def cli(options,args):
	
	log_modules.join()
	submit_modules.join()
	if options.pastebin:
		submit_module = submit_modules[options.pastebin]
		
	else:
		submit_module = submit_modules[submit_module_default]
		
	
	log_dict = {}
	
	optnumber = 0	
	
	for x in options.__dict__.iteritems():
		option = x[0]
		on = x[1]
		
		
		# Is there a nicer way to do this?
		if on and option != "pastebin" and option != "log":
			
			print option
			
			category = log_modules.getModulesInCategory(option)
			
			for log_module in category:
				module = log_modules[log_module.module_name]
				(name, contents) = module.execute()
				log_dict[name] = contents 
		
			optnumber = optnumber + 1
		
		elif options.log:
			module = log_modules[options.log]
			(name, contents) = module.execute()
			log_dict[name] = contents 
		
			optnumber = optnumber + 1
			options.log = False
	
	# Check to see if all mandatory arguments have been filled.
	
	print "%s log file(s) have been read."%(optnumber)
	
	if optnumber < 1:
		print "Please specify a log option. You haven't asked me to send anything. See help (-h) for more information."
		sys.exit(1)
	
	if len(args) != 2:
		print "Please specify the required options. See help (-h) for more information."
		sys.exit(1)
	
	
	#  Populating final variables.
	
	user_email = args[0]
	user_message = args[1]
	
	print user_message
	print user_email
	
	#user_logs = functions.get_final()
	
	submit_module.execute(user_email, user_message, log_dict)
	
	
		
		
if __name__ == "__main__": 
	
	#submit_module_default = "rafb" #hack, until we get /etc/upstream/*.conf in place
	config = ConfigParser.ConfigParser()
	config.readfp(open('%s/upstream.conf'%(uconf.base_path_default)))
	submit_module_default = config.get("main", "submit_module_default")

	l_config = uconf.PluginConfigReader(uconf.LOG, "../conf")
	log_modules = logmoduleloader.LogModuleLoader(l_config, True)

	s_config = uconf.PluginConfigReader(uconf.SUBMIT, "../conf")
	submit_modules = submitmoduleloader.SubmitModuleLoader(s_config, True)
	
	parser = optparse.OptionParser("%prog yourname \"Your support message\" [options]. If no arguments are supplied, Upstream will go in to wizard mode.")
	
	log_modules.join()
	
	categories = log_modules.getCategories()
	
	for category in categories:
		lflag = "--%s"%(category)
		print lflag

		parser.add_option("", lflag, action="store_true", help="All log modules in the %s category."%(category), default=False)

	parser.add_option("", "--pastebin", dest="pastebin", help="Specify a pastebin module to use.", default=False)

	parser.add_option("", "--log", dest="log", help="Choose a specific a log module to use.", default=False)

	(options, args) = parser.parse_args()
	
	
	if args == []:
		main()
	else:
		cli(options,args)
"""

